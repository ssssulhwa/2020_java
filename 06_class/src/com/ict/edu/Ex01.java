package com.ict.edu;

public class Ex01 {		//클래스 헤더

	// 클래스
	// 정의 : 객체 (오브젝트, object, 인스턴스Instance)를 만들기 위한 모든 정보를 갖고 있는 파일
	// (설계도면, 거푸집 등으로 표현)
	
	// 클래스가 갖고 있는 것 : 데이터(상태값,속성), 기능, 생성자
	// - 데이터(상태값) = 변수, 상수 => 멤버 필드
	// - 기능(동작)					 => 멤버 메소드
	// - 생성자 = 클래스를 객체로 만들 때 호출 됨 = 생성자	
	// 생성자 = 클래스 이름 => 저장 이름
	
	// 클래스의 구조 : 헤더, 멤버필드, 생성자, 멤버 메소드
	// 1. 헤더 : [접근제한자] [클래스종류] class 클래스이름 {멤버필드, 생성자, 멤버메소드 }
	
	// 1) 접근제한자 : 클래스, 멤버필드, 멤버메소드, 생성자 모두 맨 처음 나옴
	// 				   외부에서 접근 할 수 있는 권한의 단계를 말함
	//		가) *public : 누구나 다 접근 가능
	//		나) protected : 같은 패키지와 상속관계에서는 접근 가능
	//		다) default(생략) : 같은 패키지에서는 접근 가능 (상속 관계X)
	//		라) *private : 외부에서는 절대 접근 불가, 내부멤버(멤버필드, 멤버메소드) 끼리는 접근 가능, 캡슐화
	
	// 2) 클래스 종류: 현재 클래스의 종류를 표시함
	//				   일반적인 클래스는 이 부분 생략함
	//				   특정 클래스를 만들고, 해당하는 예약어를 사용 (final, abstract- 위치: public 바로 다음)
	
	// 3) class : 클래스임을 나타내는 예약어
	
	// 4) 클래스이름: 저장이름 = 클래스이름 = 생성자
	//				  첫 글자 대문자, 나머지 소문자, 2단어 이상은 단어의 첫 글자 대문자
	//				  특수문자, 공백문자 사용 X, 숫자는 중간이나 뒤에 사용
	
	
	// 2. 멤버필드(변수와 상수) : 상태값, 데이터, 속성, 특징 
	// 1) 변수 : 언제든지 별할 수 있는 데이터를 저장하는 공간
	//			 첫 글자 소문자, 2 단어 이상은 단어의 첫글자 대문자
	
	// 2) 상수 : 한 번 저장되면 변경 못하는 데이터를 저장하는 공간
	//			 모든 글자가 대문자, 단어와 단어 사이에 _(언더스코어) 사용 가능
	
	// 3.멤버메소드 : 동작, 기능, 작동하는 것
		// - 해당 메소드를 호출(실행)하면 해당 메소드 안에 존재하는 내용이 실행 됨
		// - 메소드는 다른 메소드 호출 가능
		// - 해당 메소드를 호출해서 내용이 끝나면 메소드를 호출한 곳으로 되돌아감
	
	// 1) 메소드 구성: [접근 제한자(public,private..)] [메소드 종류] *반환형 메소드 이름([인자=매개변수]){실행 내용}
	//		가) 접근 제한자 :  class의 접근 제한자와 같음
	//			-public, protected, 생략, private
	//		나) 메소드 종류 : 일반 메소드는 이 부분 생략함
	//						  특정 메소드 일 때는 특정 메소드에 해당하는 예약어를 사용 (static)
	//		다) 반환형 : 해당 메소드를 호출한 곳으로 되돌아 갈 때 결과의 자료형을 말함
	//					 만약 결과를 갖고 가지 않으면 'void'예약어를 사용함
	
	//		ex) public static void main(String[] args){}
	//		=> 메소드 이름은 main, 해당 메소드를 호출한 JVM에게 아무것도 안 가져감
	//		
	//		라) 메소드 이름 : 첫 글자 소문자, 나머지 소문자, 2단어 이상일 때 단어 첫 글자 대문자(변수와 같음)
	
	//		마) 인자 : 메소드가 실행될 때 필요한 정보를 외부에서 받아서 사용함 
	//		** 메소드 이름 같아도 인자 갯수와 인자 자료형이 다르면 다른 메소드로 판단함
	//				=> 오버로딩, 오버로드 : 메소드 이름이 같지만, 인자나 인자 갯수가 다를 때
	//				=> 한 클래스 안에서 같은 이름의 메소드가 여러 개 존재 하는 것 (단, 인자의 갯수와 자료형은 달라야함)
	
	//		바) *getter() : 호출하는 입장에서 메소드를 이용해서 변수값을 추출할 때
	//			*setter() : 호출하는 입장에서 메소드를 이용해서 변수값을 변경할 때
	
	//	4. static과 instance : 멤버 메소드와 멤버 필드에게 공통으로 해당되는 사항
	//	1) instance : 객체 생성
	//		- 인스턴스 필드, 인스턴스 메소드 => 객체가 생성될 때 같이 생성되는 필드와 메서드
	//		- 일반적인 클래스의 멤버 메소드나 멤버 필드는 모두 인스턴스
	//		- 호출방법 : 객체 참조 변수, 멤버 필드, 객체 참조 변수.멤버 메소드
	//		- heap 메모리에 만들어짐
	
	//	2) static
	//		- 객체 생성과 상관없이 미리 만들어진 멤버 필드와 멤버 메소드
	//		- static은 반드시 메소드나 필드에 'static' 표시 해야 됨
	//		- 언제든지 호출해서 사용 가능
	//		- static 메모리에 만들어짐 (static 없으면 모두 instance) 
	//		- 호출방법 : 클래스 이름.멤버 필드, 클래스 이름, 멤버 메소드
	//		- 대표적인 예) ; System.out.println(), main 메소드() 
	
	// 5. 생성자 : 클래스를 객체로 만들 때 한번 호출됨	
	//	1) 목적 : 멤버 필드(변수와 상수)의 초기값 지정
	
	//	2) 형식 : - 클래스 이름과 생성자는 같음
	//			  - 반환형 없는 매소드와 같음
	
	//	3) 클래스를 객체로 만드는 방법
	//		ex) Scanner sc = new Scanner (System.in) 
	//		클래스 참조변수 = new 생성자
	
	//	4) 모든 클래스는 반드시 생성자를 갖고 있음
	//	생성자가 없는 클래스는 기본 생성자가 생략 된 것
	//  기본 생성자란? 인자가 없는 생성자 	ex) 클래스이름()
	
	//	5) 멤버 필드와 멤버 메소드를 사용하기 위한 접근법
	//	   객체참조변수.멤버필드, 객체참조변수.멤버메소드
	//		ex)	sc.next(), sc.nextInt();
	
	//	6) 생성자도 오버로딩 가능 즉, 하나의 클래스 안에 여러개의 생성자가 존재 할 수 있음
	//
	
}	//
